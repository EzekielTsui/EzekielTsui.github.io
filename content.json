{"pages":[],"posts":[{"title":"C++运算符","text":"运算符优先级从上至下，优先级递减。同一行运算符具有相同的优先级，求值顺序取决于它在该表达式中的位置（从左至右）。 逻辑运算符&nbsp;&nbsp;&nbsp;&nbsp;NOT ( ! ) 算术运算符&nbsp;&nbsp;&nbsp;&nbsp;*，/，% 算术运算符&nbsp;&nbsp;&nbsp;&nbsp;+，- 关系运算符&nbsp;&nbsp;&nbsp;&nbsp;&lt;，&gt;，&lt;=，&gt;= 关系运算符&nbsp;&nbsp;&nbsp;&nbsp;==，!= 逻辑运算符&nbsp;&nbsp;&nbsp;&nbsp;AND（&amp;&amp;） 逻辑运算符&nbsp;&nbsp;&nbsp;&nbsp;OR（||） 赋值运算符&nbsp;&nbsp;&nbsp;&nbsp;= Boolean类型的标识符如何控制输出数字还是布尔值？使用iostream库来进行输入输出的话，可以通过std::boolalpha和std::noboolalpha来控制输出的是数字类型还是布尔类型（true、false）。 12345678bool isOK = true;cout &lt;&lt; isOK &lt;&lt; &quot;,&quot;;cout &lt;&lt; noboolalpha &lt;&lt; isOK &lt;&lt; &quot;,&quot;;cout &lt;&lt; boolalpha &lt;&lt; isOK &lt;&lt; &quot;\\n&quot;;// 输出：// 1,1,true NOT（!）运算符1234567891011121314151617181920bool isA = true;bool isB = 1;bool isC = 2;bool isD = -1;bool isE = 0;cout &lt;&lt; !isA &lt;&lt; &quot;,&quot; &lt;&lt; !isB &lt;&lt; &quot;,&quot; &lt;&lt; !isC &lt;&lt; &quot;,&quot; &lt;&lt; !isD &lt;&lt; &quot;,&quot; &lt;&lt; !isE &lt;&lt; &quot;\\n&quot;; //输出： //1,1,trueint a = true;int b = 1;int c = 2;int d = -1;int e = 0;cout &lt;&lt; !a &lt;&lt; &quot;,&quot; &lt;&lt; !b &lt;&lt; &quot;,&quot; &lt;&lt; !c &lt;&lt; &quot;,&quot; &lt;&lt; !d &lt;&lt; &quot;,&quot; &lt;&lt; !e &lt;&lt; &quot;\\n&quot;; //输出： //0，0，0，0，1 0视为false，其余一切值视为true。对非0的值做“！”运算，均得0；对0做“！”运算，得1。","link":"/2019/08/08/C++%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"title":"Git&amp;Ubuntu终端代理的设置和取消","text":"Git设置代理12345git config --global http.proxy 'http://127.0.0.1:1080'git config --global https.proxy 'https://127.0.0.1:1080'git config --global http.proxy 'socks5://127.0.0.1:1080'git config --global https.proxy 'socks5://127.0.0.1:1080' 取消代理12git config --global --unset http.proxygit config --global --unset https.proxy Ubuntu终端设置代理123456export http_proxy=&quot;socks5://127.0.0.1:1080&quot;export https_proxy=&quot;socks5://127.0.0.1:1080&quot;export ALL_PROXY=socks5://127.0.0.1:1080export http_proxy=&quot;http://127.0.0.1:1080&quot;export http_proxy=&quot;https://127.0.0.1:1080&quot; 取消代理123unset http_proxyunset https_proxyunset ALL_PROXY","link":"/2019/10/07/Git&Ubuntu%E7%BB%88%E7%AB%AF%E4%BB%A3%E7%90%86%E7%9A%84%E8%AE%BE%E7%BD%AE%E5%92%8C%E5%8F%96%E6%B6%88/"},{"title":"Golang学习-slice的切片与清空","text":"123456789101112131415161718192021222324252627282930313233343536package mainimport &quot;fmt&quot;func main(){ slice := []int{1, 2, 3, 4, 5} fmt.Println(slice) println(slice) println(&quot;=============================&quot;) // 切片操作一 println(&quot;切片操作一：&quot;) slice = slice[:4] fmt.Println(slice) println(slice) println(&quot;=============================&quot;) // 切片操作二 println(&quot;切片操作二：&quot;) slice = slice[2:] fmt.Println(slice) println(slice)}// 运行结果// [1 2 3 4 5]// [5/5]0xc00008c030// =============================// 切片操作一：// [1 2 3 4]// [4/5]0xc00008c030// =============================// 切片操作二：// [3 4]// [2/3]0xc00008c040// ============================= 【切片操作1】结束后，slice容量不变，指向slice的指针地址不变；而【切片操作2】会改变slice的容量和指向slice的指针地址。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package mainimport &quot;fmt&quot;func main() { slice := []int{1, 2, 3, 4, 5} fmt.Println(slice) println(slice) println(&quot;=============================&quot;) // 清空slice // 策略一 println(&quot;策略一：&quot;) slice = slice[:0] fmt.Println(slice) println(slice) println(&quot;=============================&quot;) slice = slice[:5] // 再次访问原数组 fmt.Println(slice) println(slice) println(&quot;=============================&quot;) // 策略二 println(&quot;策略二：&quot;) slice = slice[:0:0] fmt.Println(slice) println(slice) println(&quot;=============================&quot;) // slice = slice[:5] //再次访问原数组，会报错。 slice = append(slice, 9) fmt.Println(slice) println(slice) println(&quot;=============================&quot;)}// 运行结果// [1 2 3 4 5]// [5/5]0xc00000c300// =============================// 策略一：// []// [0/5]0xc00000c300// =============================// [1 2 3 4 5]// [5/5]0xc00000c300// =============================// 策略二：// []// [0/0]0xc00000c300// =============================// [9]// [1/1]0xc000014138// ============================= 【策略一】的slice仍指向原数组的地址，再次访问原数组，能访问到。访问这种策略是错误的。【策略二】的slice在未追加元素前，虽然仍指向原数组，但不能再访问原数组的元素。追加元素后，slice的地址也会改变，也就是一个全新的数组。","link":"/2019/10/01/Golang%E5%AD%A6%E4%B9%A0-slice%E7%9A%84%E5%88%87%E7%89%87%E4%B8%8E%E6%B8%85%E7%A9%BA/"},{"title":"Python 学习笔记（一）","text":"1234567891011121314151617import mathdef quadratic(a, b, c): # 简洁表达多个变量的类型是否正确 if not isinstance((a + b + c),(int,float)): raise TypeError('Bad operand type') x1 = (-b + math.sqrt(b**2 - 4 * a * c)) / (2 * a) x2 = (-b - math.sqrt(b**2 - 4 * a * c)) / (2 * a) return x1, x2result = quadratic(1, -10, 9)result1, result2 = quadratic(1, -10, 9)print(result,type(result))print(result1, result2) 多个返回值实际上还是单一值，是一个tuple类型。会按照位置赋给对应变量。","link":"/2019/08/13/Python-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"},{"title":"Linux自定义命令","text":"日常使用Linux系统开发时，会有这样的情况：1.有些Linux常用命令行的参数非常长2.该命令行早已埋没于命令行历史记录中，难以寻找这个时候，我们可以修改.bashrc文件，来自定义一些个性化的Linux命令，方便自己使用。Tips：.bashrc会在登入shell时执行。 以下是为chrome浏览器设置代理的例子： 1.启用vi编辑器修改.bachrc1sudo vi ~/.bashrc 2.为命令取别名并保存1alias chrome=&quot;sudo google-chrome --proxy_server='socks5://127.0.0.1:1080' --no-sandbox&quot; 3.使.bashrc文件生效1source ~/.bashrc 然后就可以使用 chrome 达到 sudo google-chrome –proxy_server=’socks5://127.0.0.1:1080’ –no-sandbox的效果。","link":"/2019/10/08/Linux%E8%87%AA%E5%AE%9A%E4%B9%89%E5%91%BD%E4%BB%A4/"},{"title":"Python-学习笔记（二）","text":"斐波那契数列由0和1开始，之后的斐波那契系数就是由之前的两数相加而得出。首几个斐波那契系数是：0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233…… 先给出Fibonacci数列的求解方法： 12345678# 生成器方法求Fibonacci数列def fib(max): n, a, b = 0, 0, 1 while n &lt; max: yield b a, b = b, a + b n = n + 1 return 'done' 然后，比较两种赋值方式的区别： 分开两行赋值:123456789101112131415161718192021222324252627282930313233a,b = 0,1print(a,b)print('----------------')a = bb = a+bprint(a,b)print('----------------')a = bb = a+bprint(a,b)print('----------------')a = bb = a+bprint(a,b)print('----------------')a = bb = a+bprint(a,b)print('----------------')# 运行结果:# 0 1# ----------------# 1 2# ----------------# 2 4# ----------------# 4 8# ----------------# 8 16# ---------------- 可见,b先赋值给a(即a先指向b所指向的内存),a获取了b的值（新值）,然后再进行a+b的运算,并赋值给了b。 写在一行赋值:12345678910111213141516171819202122232425262728293031323334a,b = 0,1print(a,b)print('----------------')a,b = b, a+bprint(a,b)print('----------------')a,b = b, a+bprint(a,b)print('----------------')a,b = b, a+bprint(a,b)print('----------------')a,b = b, a+bprint(a,b)print('----------------')a,b = b, a+bprint(a,b)print('----------------')# 运行结果：# 0 1# ----------------# 1 1# ----------------# 1 2# ----------------# 2 3# ----------------# 3 5# ----------------# 5 8# ---------------- 可见,进行a+b运算时，并没有先将b赋值给a，a所采用的值是 旧的 值，得出的结果与Fibonacci数列一致。","link":"/2019/08/15/Python-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"},{"title":"VMWare共享文件夹挂载","text":"Step 1：打开工具栏中的Player Step 2：选择管理 Step 3：选择虚拟机设置 Step 4：选择选项 选项卡 Step 5：选择共享文件夹 Step 6：选择总是启用 Step 7：点击添加 Step 8：根据提示填入主机路径和名称（名称会根据主机路径自动填入） Step 9：启用此共享（默认勾选） Step 10：点击完成 Step 11：挂载共享文件夹 开机自动挂载方法： 用编辑器打开/etc文件夹下的fstab文件： 1# vi /etc/fstab 末尾追加一行： 1.host:/ /mnt/hgfs fuse.vmhgfs-fuse allow_other,defaults 0 0 手动挂载方法： 1vmhgfs-fuse .host:/ /mnt/hgfs 访问共享文件夹cd至/mnt/hgfs目录下，方可访问共享文件夹。","link":"/2021/02/17/VMWare%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%A4%B9%E6%8C%82%E8%BD%BD/"},{"title":"","text":"SSH身份验证和数据传输加密过程理解SSH目标​ 一、防止中间人攻击； ​ 二、身份鉴权（密码/免密）； ​ 三、加密传输； ssh-client和ssh-server涉及的文件/文件夹​ 1）ssh-server的**/etc/ssh**，该文件夹下有多个算法生成的密钥对（公钥和私钥） ​ 2）ssh-server的/home/user下的authorized_keys ​ 3）ssh-client的/home/user下的id_rsa和id_rsa.pub ​ 4）ssh-client的/home/user下的know_hosts 各个目标的解决方案对于目标一： ​ 在ssh-client首次连接ssh-server时，ssh-server会发一段fingerprint（该段fingerprint是由ssh-server根据自己public host key计算得来）。此时，需要ssh-client自行验证，ssh-server的这台主机是否为想要连接的主机，以此防止“中间人”攻击。（通常，ssh-server的public host key需要到证书中心（CA）作公证） ​ 当ssh-client输入yes，确认目前打算的连接到的ssh-server正确的话，ssh-server的/etc/ssh下的某一个算法的public host key，会被ssh-client的/home/user下的know_hosts所记录。 对于目标二： ​ 在ssh-client首次连接ssh-server，并输入yes确认ssh-server后（或者非首次连接），ssh-server需要对ssh-client的身份作验证。其中主要有两种身份验证方式：密码/免密登录。 ​ ssh-client以密码方式登录时，在会话建立过程中，会使用ssh-server发送过来的public host key，对输入的密码进行加密。待ssh-server收到，ssh-client使用public host key加密过后的密码后，ssh-server再使用private host key进行解密，得出明文密码。最后校验ssh-client的身份。 ​ ssh-client以免密登录方式登录前，需要先使用ssh-keygen生成一对密钥，这对密钥会存放在/home/当前用户名/.ssh目录下，默认参数会生成id_ras.pub和id_rsa。然后，使用ssh-copy-id -i id_rsa.pub 远端用户名@远端ip将当前用户的公钥id_rsa.pub上传至远端ssh-server。（此操作需要输入一次远端用户对应的密码） 对于目标三： ​ 事实上，SSH会话从建立到互相传输数据，主要分为两个部分。第一部分是ssh-client和ssh-server互相验证身份，第二部分是 使用DH算法算出当前会话的、临时的共享密钥，并使用共享密钥来加密互相传输的数据。其中，第一部分中的ssh-server对ssh-client进行身份验证，使用的是非对称加密的方式，而互相传输数据，使用的是对称加密。 成功建立安全信道进行传输的必要条件ssh-server： ​ 1）安装openssh-server（意味着会有ssh-keygen） ​ 2）生成host key（安装后会自动生成） ​ 3）启动sshd服务 ssh-client： ​ 1）安装openssh-client（意味着会有ssh-keygen）","link":"/2021/02/17/SSH%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E5%92%8C%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%8A%A0%E5%AF%86%E8%BF%87%E7%A8%8B%E7%90%86%E8%A7%A3/"},{"title":"虚拟机使用宿主机代理","text":"虚拟机系统代理设置： Step 0：宿主机代理软件，打开【允许局域网连接】。 Step 1：打开System Setting Step 2：打开Network Step 3：选择Network proxy Step 4：Method选择Manual，并填入【宿主机的IP地址】和【宿主机代理软件的本地监听端口】。 终端代理设置（仅对当前终端有效）： 1234export http_proxy=&quot;http://192.168.xxx.xxx:xxxx&quot;export https_proxy=&quot;https://192.168.xxx.xxx:xxxx&quot;","link":"/2021/02/17/%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%BD%BF%E7%94%A8%E5%AE%BF%E4%B8%BB%E6%9C%BA%E4%BB%A3%E7%90%86/"}],"tags":[{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"运算符","slug":"运算符","link":"/tags/%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"Ubuntu","slug":"Ubuntu","link":"/tags/Ubuntu/"},{"name":"Terminal","slug":"Terminal","link":"/tags/Terminal/"},{"name":"Golang","slug":"Golang","link":"/tags/Golang/"},{"name":"slice","slug":"slice","link":"/tags/slice/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"}],"categories":[{"name":"C++","slug":"C","link":"/categories/C/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"学习笔记","slug":"学习笔记","link":"/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]}