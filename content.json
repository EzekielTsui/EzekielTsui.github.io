{"pages":[],"posts":[{"title":"【学习笔记】Git Bash&amp;Ubuntu终端代理的设置和取消","text":"以下记录了Git Bash和Ubuntu Terminal使用代理的方法。 Git Bash设置代理12345git config --global http.proxy 'http://127.0.0.1:1080'git config --global https.proxy 'https://127.0.0.1:1080'git config --global http.proxy 'socks5://127.0.0.1:1080'git config --global https.proxy 'socks5://127.0.0.1:1080' 取消代理12git config --global --unset http.proxygit config --global --unset https.proxy Ubuntu终端设置代理123456export http_proxy=&quot;socks5://127.0.0.1:1080&quot;export https_proxy=&quot;socks5://127.0.0.1:1080&quot;export ALL_PROXY=socks5://127.0.0.1:1080export http_proxy=&quot;http://127.0.0.1:1080&quot;export http_proxy=&quot;https://127.0.0.1:1080&quot; 取消代理123unset http_proxyunset https_proxyunset ALL_PROXY","link":"/2019/10/07/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91Git&Ubuntu%E7%BB%88%E7%AB%AF%E4%BB%A3%E7%90%86%E7%9A%84%E8%AE%BE%E7%BD%AE%E5%92%8C%E5%8F%96%E6%B6%88/"},{"title":"【学习笔记】C++运算符","text":"​ 以下记录了C++部分运算符问题。 运算符优先级从上至下，优先级递减。同一行运算符具有相同的优先级，求值顺序取决于它在该表达式中的位置（从左至右）。 逻辑运算符&nbsp;&nbsp;&nbsp;&nbsp;NOT ( ! ) 算术运算符&nbsp;&nbsp;&nbsp;&nbsp;*，/，% 算术运算符&nbsp;&nbsp;&nbsp;&nbsp;+，- 关系运算符&nbsp;&nbsp;&nbsp;&nbsp;&lt;，&gt;，&lt;=，&gt;= 关系运算符&nbsp;&nbsp;&nbsp;&nbsp;==，!= 逻辑运算符&nbsp;&nbsp;&nbsp;&nbsp;AND（&amp;&amp;） 逻辑运算符&nbsp;&nbsp;&nbsp;&nbsp;OR（||） 赋值运算符&nbsp;&nbsp;&nbsp;&nbsp;= Boolean类型的标识符如何控制输出数字还是布尔值？使用iostream库来进行输入输出的话，可以通过std::boolalpha和std::noboolalpha来控制输出的是数字类型还是布尔类型（true、false）。 12345678bool isOK = true;cout &lt;&lt; isOK &lt;&lt; &quot;,&quot;;cout &lt;&lt; noboolalpha &lt;&lt; isOK &lt;&lt; &quot;,&quot;;cout &lt;&lt; boolalpha &lt;&lt; isOK &lt;&lt; &quot;\\n&quot;;// 输出：// 1,1,true NOT（!）运算符1234567891011121314151617181920bool isA = true;bool isB = 1;bool isC = 2;bool isD = -1;bool isE = 0;cout &lt;&lt; !isA &lt;&lt; &quot;,&quot; &lt;&lt; !isB &lt;&lt; &quot;,&quot; &lt;&lt; !isC &lt;&lt; &quot;,&quot; &lt;&lt; !isD &lt;&lt; &quot;,&quot; &lt;&lt; !isE &lt;&lt; &quot;\\n&quot;; //输出： //1,1,trueint a = true;int b = 1;int c = 2;int d = -1;int e = 0;cout &lt;&lt; !a &lt;&lt; &quot;,&quot; &lt;&lt; !b &lt;&lt; &quot;,&quot; &lt;&lt; !c &lt;&lt; &quot;,&quot; &lt;&lt; !d &lt;&lt; &quot;,&quot; &lt;&lt; !e &lt;&lt; &quot;\\n&quot;; //输出： //0，0，0，0，1 0视为false，其余一切值视为true。对非0的值做“！”运算，均得0；对0做“！”运算，得1。","link":"/2019/08/08/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91C++%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"title":"【学习笔记】Golang学习-slice的切片与清空","text":"​ 以下记录了Golang有关切片（slice）的问题。 123456789101112131415161718192021222324252627282930313233343536package mainimport &quot;fmt&quot;func main(){ slice := []int{1, 2, 3, 4, 5} fmt.Println(slice) println(slice) println(&quot;=============================&quot;) // 切片操作一 println(&quot;切片操作一：&quot;) slice = slice[:4] fmt.Println(slice) println(slice) println(&quot;=============================&quot;) // 切片操作二 println(&quot;切片操作二：&quot;) slice = slice[2:] fmt.Println(slice) println(slice)}// 运行结果// [1 2 3 4 5]// [5/5]0xc00008c030// =============================// 切片操作一：// [1 2 3 4]// [4/5]0xc00008c030// =============================// 切片操作二：// [3 4]// [2/3]0xc00008c040// ============================= 【切片操作1】结束后，slice容量不变，指向slice的指针地址不变；而【切片操作2】会改变slice的容量和指向slice的指针地址。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package mainimport &quot;fmt&quot;func main() { slice := []int{1, 2, 3, 4, 5} fmt.Println(slice) println(slice) println(&quot;=============================&quot;) // 清空slice // 策略一 println(&quot;策略一：&quot;) slice = slice[:0] fmt.Println(slice) println(slice) println(&quot;=============================&quot;) slice = slice[:5] // 再次访问原数组 fmt.Println(slice) println(slice) println(&quot;=============================&quot;) // 策略二 println(&quot;策略二：&quot;) slice = slice[:0:0] fmt.Println(slice) println(slice) println(&quot;=============================&quot;) // slice = slice[:5] //再次访问原数组，会报错。 slice = append(slice, 9) fmt.Println(slice) println(slice) println(&quot;=============================&quot;)}// 运行结果// [1 2 3 4 5]// [5/5]0xc00000c300// =============================// 策略一：// []// [0/5]0xc00000c300// =============================// [1 2 3 4 5]// [5/5]0xc00000c300// =============================// 策略二：// []// [0/0]0xc00000c300// =============================// [9]// [1/1]0xc000014138// ============================= 【策略一】的slice仍指向原数组的地址，再次访问原数组，能访问到。访问这种策略是错误的。【策略二】的slice在未追加元素前，虽然仍指向原数组，但不能再访问原数组的元素。追加元素后，slice的地址也会改变，也就是一个全新的数组。","link":"/2019/10/01/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91Golang%E5%AD%A6%E4%B9%A0-slice%E7%9A%84%E5%88%87%E7%89%87%E4%B8%8E%E6%B8%85%E7%A9%BA/"},{"title":"【学习笔记】Linux自定义命令","text":"日常使用Linux系统开发时，会有这样的情况：1.有些Linux常用命令行的参数非常长2.该命令行早已埋没于命令行历史记录中，难以寻找这个时候，我们可以修改.bashrc文件，来自定义一些个性化的Linux命令，方便自己使用。Tips：.bashrc会在登入shell时执行。 以下是为chrome浏览器设置代理的例子： 1.启用vi编辑器修改.bachrc1sudo vi ~/.bashrc 2.为命令取别名并保存1alias chrome=&quot;sudo google-chrome --proxy_server='socks5://127.0.0.1:1080' --no-sandbox&quot; 3.使.bashrc文件生效1source ~/.bashrc 然后就可以使用 chrome 达到 sudo google-chrome –proxy_server=’socks5://127.0.0.1:1080’ –no-sandbox的效果。","link":"/2019/10/08/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91Linux%E8%87%AA%E5%AE%9A%E4%B9%89%E5%91%BD%E4%BB%A4/"},{"title":"【学习笔记】Python学习笔记（一）-多值返回","text":"多个返回值实际上还是单一值，是一个tuple类型。会按照位置赋给对应变量。 12345678910111213141516import mathdef quadratic(a, b, c): # 简洁表达多个变量的类型是否正确 if not isinstance((a + b + c),(int,float)): raise TypeError('Bad operand type') x1 = (-b + math.sqrt(b**2 - 4 * a * c)) / (2 * a) x2 = (-b - math.sqrt(b**2 - 4 * a * c)) / (2 * a) return x1, x2result = quadratic(1, -10, 9)result1, result2 = quadratic(1, -10, 9)print(result,type(result))print(result1, result2)","link":"/2019/08/13/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89-%E5%A4%9A%E5%80%BC%E8%BF%94%E5%9B%9E/"},{"title":"【学习笔记】Python学习笔记（二）-赋值方式","text":"斐波那契数列由0和1开始，之后的斐波那契系数就是由之前的两数相加而得出。首几个斐波那契系数是：0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233…… 先给出Fibonacci数列的求解方法： 12345678# 生成器方法求Fibonacci数列def fib(max): n, a, b = 0, 0, 1 while n &lt; max: yield b a, b = b, a + b n = n + 1 return 'done' 然后，比较两种赋值方式的区别： 分开两行赋值:123456789101112131415161718192021222324252627282930313233a,b = 0,1print(a,b)print('----------------')a = bb = a+bprint(a,b)print('----------------')a = bb = a+bprint(a,b)print('----------------')a = bb = a+bprint(a,b)print('----------------')a = bb = a+bprint(a,b)print('----------------')# 运行结果:# 0 1# ----------------# 1 2# ----------------# 2 4# ----------------# 4 8# ----------------# 8 16# ---------------- 可见,b先赋值给a(即a先指向b所指向的内存),a获取了b的值（新值）,然后再进行a+b的运算,并赋值给了b。 写在一行赋值:12345678910111213141516171819202122232425262728293031323334a,b = 0,1print(a,b)print('----------------')a,b = b, a+bprint(a,b)print('----------------')a,b = b, a+bprint(a,b)print('----------------')a,b = b, a+bprint(a,b)print('----------------')a,b = b, a+bprint(a,b)print('----------------')a,b = b, a+bprint(a,b)print('----------------')# 运行结果：# 0 1# ----------------# 1 1# ----------------# 1 2# ----------------# 2 3# ----------------# 3 5# ----------------# 5 8# ---------------- 可见,进行a+b运算时，并没有先将b赋值给a，a所采用的值是 旧的 值，得出的结果与Fibonacci数列一致。","link":"/2019/08/15/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89-%E8%B5%8B%E5%80%BC%E6%96%B9%E5%BC%8F/"},{"title":"【学习笔记】SSH身份验证和数据传输加密过程理解","text":"SSH目标​ 一、防止中间人攻击； ​ 二、身份鉴权（密码/免密）； ​ 三、加密传输； ssh-client和ssh-server涉及的文件/文件夹​ 1）ssh-server的**/etc/ssh**，该文件夹下有多个算法生成的密钥对（公钥和私钥） ​ 2）ssh-server的/home/user下的authorized_keys ​ 3）ssh-client的/home/user下的id_rsa和id_rsa.pub ​ 4）ssh-client的/home/user下的know_hosts 各个目标的解决方案对于目标一： ​ 在ssh-client首次连接ssh-server时，ssh-server会发一段fingerprint（该段fingerprint是由ssh-server根据自己public host key计算得来）。此时，需要ssh-client自行验证，ssh-server的这台主机是否为想要连接的主机，以此防止“中间人”攻击。（通常，ssh-server的public host key需要到证书中心（CA）作公证） ​ 当ssh-client输入yes，确认目前打算的连接到的ssh-server正确的话，ssh-server的/etc/ssh下的某一个算法的public host key，会被ssh-client的/home/user下的know_hosts所记录。 对于目标二： ​ 在ssh-client首次连接ssh-server，并输入yes确认ssh-server后（或者非首次连接），ssh-server需要对ssh-client的身份作验证。其中主要有两种身份验证方式：密码/免密登录。 ​ ssh-client以密码方式登录时，在会话建立过程中，会使用ssh-server发送过来的public host key，对输入的密码进行加密。待ssh-server收到，ssh-client使用public host key加密过后的密码后，ssh-server再使用private host key进行解密，得出明文密码。最后校验ssh-client的身份。 ​ ssh-client以免密登录方式登录前，需要先使用ssh-keygen生成一对密钥，这对密钥会存放在/home/当前用户名/.ssh目录下，默认参数会生成id_ras.pub和id_rsa。然后，使用ssh-copy-id -i id_rsa.pub 远端用户名@远端ip将当前用户的公钥id_rsa.pub上传至远端ssh-server。（此操作需要输入一次远端用户对应的密码） 对于目标三： ​ 事实上，SSH会话从建立到互相传输数据，主要分为两个部分。第一部分是ssh-client和ssh-server互相验证身份，第二部分是 使用DH算法算出当前会话的、临时的共享密钥，并使用共享密钥来加密互相传输的数据。其中，第一部分中的ssh-server对ssh-client进行身份验证，使用的是非对称加密的方式，而互相传输数据，使用的是对称加密。 成功建立安全信道进行传输的必要条件ssh-server： ​ 1）安装openssh-server（意味着会有ssh-keygen） ​ 2）生成host key（安装后会自动生成） ​ 3）启动sshd服务 ssh-client： ​ 1）安装openssh-client（意味着会有ssh-keygen）","link":"/2021/02/13/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91SSH%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E5%92%8C%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%8A%A0%E5%AF%86%E8%BF%87%E7%A8%8B%E7%90%86%E8%A7%A3/"},{"title":"【常用工具使用方法】虚拟机使用宿主机代理","text":"​ 以下以VMWare为例，记录了如何使得虚拟机使用宿主机代理的方法。 虚拟机系统代理设置： Step 0：宿主机代理软件，打开【允许局域网连接】。 Step 1：打开System Setting Step 2：打开Network Step 3：选择Network proxy Step 4：Method选择Manual，并填入【宿主机的IP地址】和【宿主机代理软件的本地监听端口】。 终端代理设置（仅对当前终端有效）： 1234export http_proxy=&quot;http://192.168.xxx.xxx:xxxx&quot;export https_proxy=&quot;https://192.168.xxx.xxx:xxxx&quot;","link":"/2021/02/17/%E3%80%90%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E3%80%91%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%BD%BF%E7%94%A8%E5%AE%BF%E4%B8%BB%E6%9C%BA%E4%BB%A3%E7%90%86/"},{"title":"【学习笔记】进程间&#x2F;线程间通信（零）","text":"​ 进程间通信（IPC，Inter-Process Communication），指至少两个进程或线程间传送数据或信号的一些技术或方法。 ​ 进程是计算机系统分配资源的最小单位（严格说来是线程）。每个进程都有自己的一部分独立的系统资源，彼此是隔离的。为了能使不同的进程互相访问资源并进行协调工作，才有了进程间通信。通常，使用进程间通信的两个应用可以被分为客户端和服务器（见主从式架构），客户端进程请求数据，服务端响应客户端的数据请求。有一些应用本身既是服务器又是客户端，这在分布式计算中，时常可以见到。这些进程可以运行在同一计算机上或网络连接的不同计算机上。 Method Description Provided by (operating systems or other environments) 文件（File） A record stored on disk, or a record synthesized on demand by a file server, which can be accessed by multiple processes. Most operating systems 信号量（Signal） A system message sent from one process to another, not usually used to transfer data but instead used to remotely command the partnered process. Most operating systems 套接字（Socket） Data sent over a network interface, either to a different process on the same computer or to another computer on the network. Stream-oriented (TCP; data written through a socket requires formatting to preserve message boundaries) or more rarely message-oriented (UDP, SCTP). Most operating systems Unix domain socket Similar to an internet socket, but all communication occurs within the kernel. Domain sockets use the file system as their address space. Processes reference a domain socket as an inode, and multiple processes can communicate with one socket All POSIX operating systems and Windows 10 消息队列（Message queue） A data stream similar to a socket, but which usually preserves message boundaries. Typically implemented by the operating system, they allow multiple processes to read and write to the message queue without being directly connected to each other. Most operating systems 匿名管道（Anonymous pipe） A unidirectional data channel using standard input and output. Data written to the write-end of the pipe is buffered by the operating system until it is read from the read-end of the pipe. Two-way communication between processes can be achieved by using two pipes in opposite “directions”. All POSIX systems, Windows 命名管道（Named pipe） A pipe that is treated like a file. Instead of using standard input and output as with an anonymous pipe, processes write to and read from a named pipe, as if it were a regular file. All POSIX systems, Windows, AmigaOS 2.0+ 共享内存（Shared memory） Multiple processes are given access to the same block of memory, which creates a shared buffer for the processes to communicate with each other. All POSIX systems, Windows 消息传递（Message passing） Allows multiple programs to communicate using message queues and/or non-OS managed channels. Commonly used in concurrency models. Used in RPC, RMI, and MPI paradigms, Java RMI, CORBA, DDS, MSMQ, MailSlots, QNX, others 内存映射文件（Memory-mapped file） A file mapped to RAM and can be modified by changing memory addresses directly instead of outputting to a stream. This shares the same benefits as a standard file. All POSIX systems, Windows Reference : https://zh.wikipedia.org/wiki/%E8%A1%8C%E7%A8%8B%E9%96%93%E9%80%9A%E8%A8%8A https://en.wikipedia.org/wiki/Inter-process_communication","link":"/2021/02/18/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E8%BF%9B%E7%A8%8B%E9%97%B4%E6%88%96%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%88%E9%9B%B6%EF%BC%89/"},{"title":"【金融理财】基金常识","text":"​ 为增加被动收入打个基础。 支付宝基金常识1、基金名称后缀含义。A代表有前端申购费用，买的时候会有手续费，适合长期持有；C代表买的时候无手续费，买的时候无手续费，持有运营过程中持续收费，2%左右。 2、中证500和沪深300。 中证500：A股市场中500家中小规模的公司（基数低，易翻倍） 描述：进攻型基金 沪深300：我们国家股票市场上的300支规模比较大，业绩也比较稳定的公司 描述：大概率长期是可以赚到钱。沪深300在市场环境不怎么好的适合，作为护盘的角色出现；当市场环境特别好的时候，它的表现就不一定能够超越大盘指数的涨幅。 3、基金名称带增强的含义。以沪深300为例，原本只能买沪深300指数编制中的公司，但如果基金名称带增强，那么它大部分会买沪深300指数以内的公司，其他会买沪深300指数以外的公司。同类产品中，比较激进。 4、基金经理从业年限。基金经理从业年限最好是3年以上，5年以上更加稳妥。","link":"/2021/02/18/%E3%80%90%E9%87%91%E8%9E%8D%E7%90%86%E8%B4%A2%E3%80%91%E5%9F%BA%E9%87%91%E5%B8%B8%E8%AF%86/"},{"title":"【金融理财】基金分类","text":"​ 为增加被动收入打个基础。 风险高到低， 股票型/QDII型/混合型 指数型 FOF型 债券基金（纯债基金、混合债基金、可转债基金） 货币型 风险和受益是对等的。 各类基金解析股票型/QDII型/混合型： 指数型：分为宽基指数基金，窄基指数基金（又叫行业指数基金）。 窄基指数基金：一般是针对某一个行业的指数型基金，需要对该行业有一定的了解和认知。 宽基指数基金：不论什么行业，只有公司规模大小的区别。 目前主流的四种指数，大公司指数【沪深300，上证50】，中小公司指数【中证500，创业板指】。 沪深300：我们国家内地市场上，有两个主要的证券交易所，一个在上海（上海证券交易所），一个在深圳（深圳证券交易所）。沪深300就是这两个市场加在一起，挑300家规模最大、流动性最好的公司，编进这个指数。 风格：金融和地产的占比比较大，其次混合了消费、工业等，和国家经济息息相关。特别稳。 上证50：挑上海50家规模最大、流动性最好的公司，编进这个指数。 中证500：以消费和工业为主导的指数类型。 创业板指：风险最高的宽基指数。行业分布主要是医药、工业、互联网信息技术。大部分是新兴产业，很大程度上反映了新兴产业公司发展的状况。 FOF型：会规避掉不好的基金。但多重手续费，最后受益除去手续费没有多少。 债券基金（纯债基金、混合债基金、可转债基金）： 纯债：基金持仓基本是用来买国债、企业债。年化一般在3% ~ 4.5%。 混合债：一大半用来买债券，债券包括国债、企业债和可转债，一小部分用来买股票或其他。买混合债，是希望稳重求进，收益率稍微高一点点，但风险又不要太大。40%以上用于买股票，风险略高，不大符合买混合债基金的原始目标。债券持仓比例，债券的持仓比例在70%-90%比较合适， 可转债：名义上是债券，实际上有公司和股票的属性。当公司想做一件事情，但又暂时不想拿自己的钱出来的时候，就会向市面上发售一些债券。这些债券当中，一小部分可以转换成公司的股票，这部分就叫做可转债金。（新手放弃） 货币型：货币型基金主要投资于债券、央行票据、回购等安全性极高的短期金融品种，又被称为“准储蓄产品”，其主要特征是“本金无忧、活期便利、定期收益、每日记收益、按月分红利”。 货币型基金只投资于货币市场，如短期国债、回购、央行票据、银行存款等等，风险基本没有。","link":"/2021/02/18/%E3%80%90%E9%87%91%E8%9E%8D%E7%90%86%E8%B4%A2%E3%80%91%E5%9F%BA%E9%87%91%E5%88%86%E7%B1%BB/"},{"title":"【常用工具使用方法】VMWare共享文件夹挂载","text":"​ 以下记录了VMWare与宿主机之间，共享文件夹的配置方法。 共享文件夹挂载共享文件夹功能开启详细步骤Step 1：打开工具栏中的Player Step 2：选择管理 Step 3：选择虚拟机设置 Step 4：选择选项 选项卡 Step 5：选择共享文件夹 Step 6：选择总是启用 Step 7：点击添加 Step 8：根据提示填入主机路径和名称（名称会根据主机路径自动填入） Step 9：启用此共享（默认勾选） Step 10：点击完成 Step 11：挂载共享文件夹 开机自动挂载方法：用编辑器打开/etc文件夹下的fstab文件： 1# vi /etc/fstab 末尾追加一行： 1.host:/ /mnt/hgfs fuse.vmhgfs-fuse allow_other,defaults 0 0 手动挂载方法：1vmhgfs-fuse .host:/ /mnt/hgfs 访问共享文件夹cd至/mnt/hgfs目录下，方可访问共享文件夹。","link":"/2021/02/17/%E3%80%90%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E3%80%91VMWare%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%A4%B9%E6%8C%82%E8%BD%BD/"},{"title":"【金融理财】投资策略","text":"​ 为增加被动收入打个基础。 资金分配参考比例60%股票 30%基金 10%理财产品 投资策略中证500+沪深300","link":"/2021/02/18/%E3%80%90%E9%87%91%E8%9E%8D%E7%90%86%E8%B4%A2%E3%80%91%E6%8A%95%E8%B5%84%E7%AD%96%E7%95%A5/"}],"tags":[{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"go","slug":"go","link":"/tags/go/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"ssh","slug":"ssh","link":"/tags/ssh/"},{"name":"virtual machine","slug":"virtual-machine","link":"/tags/virtual-machine/"},{"name":"IPC","slug":"IPC","link":"/tags/IPC/"},{"name":"fund","slug":"fund","link":"/tags/fund/"}],"categories":[{"name":"学习笔记","slug":"学习笔记","link":"/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"常用工具使用方法","slug":"常用工具使用方法","link":"/categories/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"},{"name":"金融理财","slug":"金融理财","link":"/categories/%E9%87%91%E8%9E%8D%E7%90%86%E8%B4%A2/"}]}