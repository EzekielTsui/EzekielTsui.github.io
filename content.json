{"pages":[],"posts":[{"title":"【学习笔记】C++运算符","text":"​ 以下记录了C++部分运算符问题。 运算符优先级从上至下，优先级递减。同一行运算符具有相同的优先级，求值顺序取决于它在该表达式中的位置（从左至右）。 逻辑运算符&nbsp;&nbsp;&nbsp;&nbsp;NOT ( ! ) 算术运算符&nbsp;&nbsp;&nbsp;&nbsp;*，/，% 算术运算符&nbsp;&nbsp;&nbsp;&nbsp;+，- 关系运算符&nbsp;&nbsp;&nbsp;&nbsp;&lt;，&gt;，&lt;=，&gt;= 关系运算符&nbsp;&nbsp;&nbsp;&nbsp;==，!= 逻辑运算符&nbsp;&nbsp;&nbsp;&nbsp;AND（&amp;&amp;） 逻辑运算符&nbsp;&nbsp;&nbsp;&nbsp;OR（||） 赋值运算符&nbsp;&nbsp;&nbsp;&nbsp;= Boolean类型的标识符如何控制输出数字还是布尔值？使用iostream库来进行输入输出的话，可以通过std::boolalpha和std::noboolalpha来控制输出的是数字类型还是布尔类型（true、false）。 12345678bool isOK = true;cout &lt;&lt; isOK &lt;&lt; &quot;,&quot;;cout &lt;&lt; noboolalpha &lt;&lt; isOK &lt;&lt; &quot;,&quot;;cout &lt;&lt; boolalpha &lt;&lt; isOK &lt;&lt; &quot;\\n&quot;;// 输出：// 1,1,true NOT（!）运算符1234567891011121314151617181920bool isA = true;bool isB = 1;bool isC = 2;bool isD = -1;bool isE = 0;cout &lt;&lt; !isA &lt;&lt; &quot;,&quot; &lt;&lt; !isB &lt;&lt; &quot;,&quot; &lt;&lt; !isC &lt;&lt; &quot;,&quot; &lt;&lt; !isD &lt;&lt; &quot;,&quot; &lt;&lt; !isE &lt;&lt; &quot;\\n&quot;; //输出： //1,1,trueint a = true;int b = 1;int c = 2;int d = -1;int e = 0;cout &lt;&lt; !a &lt;&lt; &quot;,&quot; &lt;&lt; !b &lt;&lt; &quot;,&quot; &lt;&lt; !c &lt;&lt; &quot;,&quot; &lt;&lt; !d &lt;&lt; &quot;,&quot; &lt;&lt; !e &lt;&lt; &quot;\\n&quot;; //输出： //0，0，0，0，1 0视为false，其余一切值视为true。对非0的值做“！”运算，均得0；对0做“！”运算，得1。","link":"/2019/08/08/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91C++%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"title":"【学习笔记】Git Bash&amp;Ubuntu终端代理的设置和取消","text":"​ 以下记录了Git Bash和Ubuntu Terminal使用代理的方法。 Git Bash设置代理12345git config --global http.proxy 'http://127.0.0.1:1080'git config --global https.proxy 'https://127.0.0.1:1080'git config --global http.proxy 'socks5://127.0.0.1:1080'git config --global https.proxy 'socks5://127.0.0.1:1080' 取消代理12git config --global --unset http.proxygit config --global --unset https.proxy Ubuntu终端设置代理123456export http_proxy=&quot;socks5://127.0.0.1:1080&quot;export https_proxy=&quot;socks5://127.0.0.1:1080&quot;export ALL_PROXY=socks5://127.0.0.1:1080export http_proxy=&quot;http://127.0.0.1:1080&quot;export http_proxy=&quot;https://127.0.0.1:1080&quot; 取消代理123unset http_proxyunset https_proxyunset ALL_PROXY","link":"/2019/10/07/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91Git&Ubuntu%E7%BB%88%E7%AB%AF%E4%BB%A3%E7%90%86%E7%9A%84%E8%AE%BE%E7%BD%AE%E5%92%8C%E5%8F%96%E6%B6%88/"},{"title":"【坑】strcpy()、memcpy()及strlen()","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;记录一下遇到过的坑。总结一下，在对字符串处理方面，strcpy()和memcpy()的区别，以及strlen()对memcpy()的影响。 函数原型strcpy()1char * strcpy ( char * destination, const char * source ); Description Copy string. Copies the C string pointed by source into the array pointed by destination, including the terminating null character (and stopping at that point). To avoid overflows, the size of the array pointed by destination shall be long enough to contain the same C string as source (including the terminating null character), and should not overlap in memory with source. Parameters destination Pointer to the destination array where the content is to be copied. source C string to be copied. Return Value destination is returned. memcpy()1void * memcpy ( void * destination, const void * source, size_t num ); Description Copy block of memory. Copies the values of num bytes from the location pointed to by source directly to the memory block pointed to by destination. The underlying type of the objects pointed to by both the source and destination pointers are irrelevant for this function; The result is a binary copy of the data. The function does not check for any terminating null character in source - it always copies exactly num bytes. To avoid overflows, the size of the arrays pointed to by both the destination and source parameters, shall be at least num bytes, and should not overlap (for overlapping memory blocks, memmove is a safer approach). Parameters destination Pointer to the destination array where the content is to be copied, type-casted to a pointer of type void*. source Pointer to the source of data to be copied, type-casted to a pointer of type const void*. num Number of bytes to copy. size_t is an unsigned integral type. Return Value destination is returned. strlen()1size_t strlen ( const char * str ); Description Get string length. Returns the length of the C string str. The length of a C string is determined by the terminating null-character: A C string is as long as the number of characters between the beginning of the string and the terminating null character (without including the terminating null character itself). This should not be confused with the size of the array that holds the string. For example: 1char mystr[100]=&quot;test string&quot;; defines an array of characters with a size of 100 chars, but the C string with which mystr has been initialized has a length of only 11 characters. Therefore, while sizeof(mystr) evaluates to 100, strlen(mystr) returns 11. In C++, char_traits::length implements the same behavior. Parameters str C string. Return Value The length of string. 举例前提：通常，我们需要采用消息队列的方式，将消息到各个模块时，而消息通常需要填充消息头和消息缓存（buff）两个部分，这两个部分共同组成一条消息。消息头通常以=赋值即可，没有什么坑，而buff部分，才是今天的重点。 假设，现在需要将两个char *类型的字符串（字符串1：dnmd和字z符串2：pujie，注：这两个字符串包含\\0结束符），按顺序填入buff，需保留各字符串的\\0结束符 下面分情况讨论，以不同方式使用strcpy()、memcpy()、strlen()来填充buff，对buff的内容会有什么影响。 填充buff，主要分为三个动作，获取源字符串的长度，拷贝字符串到buff和移动指针。 情况一&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;获取源字符串长度length。使用strlen()作为字符串的长度。注意，strlen()，返回的字符串长度，不包含’\\0’结束符，详见上述函数原型。例：strlen(“dnmd”)，返回4。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;拷贝字符串到buff。通过memcpy()拷贝字符串到buff。void * memcpy ( void * destination, const void * source, size_t num );，将source所指向的内存，复制n个字节到destination指向的内存，此处num取strlen(str)，即不包含\\0结束符。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;移动指针。p = p-&gt;buff[length] 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;#include &lt;cstring&gt;int main(){ const char* str1 = &quot;dnmd&quot;; const char* str2 = &quot;pujie&quot;; int length_1 = 0; int length_2 = 0; char* str = new char[20]; char* p = str; /*********fill str1 to buff************************/ // obtain str length length_1 = strlen(str1); // fill buff memcpy(p, str1, length_1); // move point p += length_1; /**************************************************/ /********fill str2 to buff*************************/ // obtain str length length_2 = strlen(str2); // fill buff memcpy(p, str2, length_2); // move point p += length_1; /**************************************************/ p = str; printf(&quot;str1:%s\\n&quot;, p); p += length_1; printf(&quot;str2:%s\\n&quot;, p); delete[] str; return 0;} 打印输出： 12str1:dnmdpujiestr2:pujie 当打印str1(dnmd)时，也会把str2(pujie)打印出来。这显然不是我们所期望看见的。 结果分析： 需要知道的是，在初始化str1后，str1的长度是5（包括\\0结束符），而strlen()获取的字符串长度为4，没有把\\0结束复包括进来。同理，str2的长度是6（包括\\0结束符），而strlen()获取的字符串长度为5。 按照以上代码，我们一步一步推导， ① 使用strlen(str1)作为字符串长度length_1（值为4）； ② 使用memcpy()把字符串str1填充buff，str1的前4个字节被填入buff，没有填入\\0结束符，此时buff的前4个字节被填入数据； ③ 跳转指针，指针p由最初指向的第1个字节，+4，指向了第5个字节； ④ 获取str2的字符串长度length_2（值为5）； ⑤ 使用memcpy()字符串str2填充buff，str2的前5个字节被填入buff，没有填入\\0结束符，此时buff的前4 + 5个字节被填入数据。 注：初始化字符串数组str后，字符串数组中的值默认为0，而\\0结束符的ASCII码恰好为0。当使用%s作为打印占位符时，遇到\\0结束符才会中止打印。 由于两次memcpy()均未将str1和str2的\\0结束符填入buff，而字符串数组的默认值为0，自带\\0结束符。 所以，在打印str1时，因为直到buff的第10个字节，才遇到\\0结束符，所以打印结果为str1:dnmdpujie，表现为异常；在打印str2时，同样的，直到buff的第10个字节，才遇到\\0结束符，所以打印结果为str2:pujie，表现为正常。 内存存储情况如图： 情况二&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;获取源字符串长度。与情况一相同。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;拷贝字符串到buff。使用strcpy()来拷贝字符串到buff，而非使用memcpy()。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;移动指针。与情况一相同。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;#include &lt;cstring&gt;int main(){ const char* str1 = &quot;dnmd&quot;; const char* str2 = &quot;pujie&quot;; int length_1 = 0; int length_2 = 0; char* str = new char[20]; char* p = str; /*********fill str1 to buff************************/ // obtain str length length_1 = strlen(str1); // fill buff strcpy(p, str1); // move point p += length_1; /**************************************************/ /********fill str2 to buff*************************/ // obtain str length : length_2 = strlen(str2); // fill buff strcpy(p, str2); // move point p += length_1; /**************************************************/ p = str; printf(&quot;str1:%s\\n&quot;, p); p += length_1; printf(&quot;str2:%s\\n&quot;, p); delete[] str; return 0;} 打印输出： 12str1:dnmdpujiestr2:pujie 结果分析： ① 同样的，使用strlen()作为str1的字符串长度length_1（值为4）； ② 与情况一不同的是，使用strcpy()填充字符串str1的话，，str1的5个字节全被被填入buff，包括了\\0结束符，此时buff的前5个字节被填入数据； ③ 跳转指针，指针p由最初指向的第1个字节，+4，指向了第5个字节； ④ 使用strlen(str2)作为字符串的长度length_2（值为5）； ⑤ 使用strcpy()字符串str2填充buff，str2的6个字节全部被填入buff，包括了\\0结束符，此时buff的前4 + 6个字节被填入数据。 实际上，这与情况一的内存存储情况相同。因为，在填入str2之前，由于指针同样指向了第5个字节，那么，在填入str2之后，原来str1的\\0结束符就被str2所覆盖了。所以打印结果与情况一相同。 内存存储情况如图： 情况三&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;获取源字符串长度。使用strlen() + 1作为字符串的长度，而非strlen()。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;拷贝字符串到buff。通过memcpy()拷贝字符串到buff。void * memcpy ( void * destination, const void * source, size_t num );，将source所指向的内存，复制n个字节到destination指向的内存，此处num取strlen(str)，即不包含\\0结束符。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;移动指针。与情况一相同。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;#include &lt;cstring&gt;int main(){ const char* str1 = &quot;dnmd&quot;; const char* str2 = &quot;pujie&quot;; int length_1 = 0; int length_2 = 0; char* str = new char[20]; char* p = str; /*********fill str1 to buff************************/ // obtain str length length_1 = strlen(str1) + 1; // fill buff memcpy(p, str1, length_1); // move point p += length_1; /**************************************************/ /********fill str2 to buff*************************/ // obtain str length : length_2 = strlen(str2) + 1; // fill buff memcpy(p, str2, length_2); // move point p += length_1; /**************************************************/ p = str; printf(&quot;str1:%s\\n&quot;, p); p += length_1; printf(&quot;str2:%s\\n&quot;, p); delete[] str; return 0;} 打印输出： 12str1:dnmdstr2:pujie 结果分析： ① 这次使用strlen() + 1作为str1的字符串长度length_1（值为5），而不是前两种情况的值4； ② 使用memcpy()把字符串str1填充buff后，str1的5个字节全被被填入buff，包括了\\0结束符，此时buff的前5个字节被填入数据； ③ 与前两种情况不一样，由于使用了strlen() + 1作为字符串str1的长度，所以在跳转指针时，指针p由最初指向的第1个字节，+5，指向了第6个字节，不同于之前的第5个字节； ④ 这次使用strlen() + 1作为str2的字符串长度length_2（值为6），而不是前两种情况的值5； ⑤ 使用memcpy()字符串str2填充buff后，str2的6个字节全部被填入buff，包括了\\0结束符，此时buff的前5 + 6个字节被填入数据； 这种情况下，字符串str1和字符串str2的\\0结束符都得以保留，所以打印结果正常。 内存存储情况如图：","link":"/2021/05/05/%E3%80%90%E5%9D%91%E3%80%91strcpy()%E3%80%81memcpy()%E5%8F%8Astrlen()/"},{"title":"【学习笔记】Golang学习-slice的切片与清空","text":"​ 以下记录了Golang有关切片（slice）的问题。 123456789101112131415161718192021222324252627282930313233343536package mainimport &quot;fmt&quot;func main(){ slice := []int{1, 2, 3, 4, 5} fmt.Println(slice) println(slice) println(&quot;=============================&quot;) // 切片操作一 println(&quot;切片操作一：&quot;) slice = slice[:4] fmt.Println(slice) println(slice) println(&quot;=============================&quot;) // 切片操作二 println(&quot;切片操作二：&quot;) slice = slice[2:] fmt.Println(slice) println(slice)}// 运行结果// [1 2 3 4 5]// [5/5]0xc00008c030// =============================// 切片操作一：// [1 2 3 4]// [4/5]0xc00008c030// =============================// 切片操作二：// [3 4]// [2/3]0xc00008c040// ============================= 【切片操作1】结束后，slice容量不变，指向slice的指针地址不变；而【切片操作2】会改变slice的容量和指向slice的指针地址。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package mainimport &quot;fmt&quot;func main() { slice := []int{1, 2, 3, 4, 5} fmt.Println(slice) println(slice) println(&quot;=============================&quot;) // 清空slice // 策略一 println(&quot;策略一：&quot;) slice = slice[:0] fmt.Println(slice) println(slice) println(&quot;=============================&quot;) slice = slice[:5] // 再次访问原数组 fmt.Println(slice) println(slice) println(&quot;=============================&quot;) // 策略二 println(&quot;策略二：&quot;) slice = slice[:0:0] fmt.Println(slice) println(slice) println(&quot;=============================&quot;) // slice = slice[:5] //再次访问原数组，会报错。 slice = append(slice, 9) fmt.Println(slice) println(slice) println(&quot;=============================&quot;)}// 运行结果// [1 2 3 4 5]// [5/5]0xc00000c300// =============================// 策略一：// []// [0/5]0xc00000c300// =============================// [1 2 3 4 5]// [5/5]0xc00000c300// =============================// 策略二：// []// [0/0]0xc00000c300// =============================// [9]// [1/1]0xc000014138// ============================= 【策略一】的slice仍指向原数组的地址，再次访问原数组，能访问到。访问这种策略是错误的。【策略二】的slice在未追加元素前，虽然仍指向原数组，但不能再访问原数组的元素。追加元素后，slice的地址也会改变，也就是一个全新的数组。","link":"/2019/10/01/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91Golang%E5%AD%A6%E4%B9%A0-slice%E7%9A%84%E5%88%87%E7%89%87%E4%B8%8E%E6%B8%85%E7%A9%BA/"},{"title":"【学习笔记】Linux自定义命令","text":"日常使用Linux系统开发时，会有这样的情况：1.有些Linux常用命令行的参数非常长2.该命令行早已埋没于命令行历史记录中，难以寻找这个时候，我们可以修改.bashrc文件，来自定义一些个性化的Linux命令，方便自己使用。Tips：.bashrc会在登入shell时执行。 以下是为chrome浏览器设置代理的例子： 启用vi编辑器修改.bachrc1sudo vi ~/.bashrc 为命令取别名并保存1alias chrome=&quot;sudo google-chrome --proxy_server='socks5://127.0.0.1:1080' --no-sandbox&quot; 使.bashrc文件生效1source ~/.bashrc 然后就可以使用 chrome 达到 sudo google-chrome –proxy_server=’socks5://127.0.0.1:1080’ –no-sandbox的效果。","link":"/2019/10/08/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91Linux%E8%87%AA%E5%AE%9A%E4%B9%89%E5%91%BD%E4%BB%A4/"},{"title":"【学习笔记】Python学习笔记（一）-多值返回","text":"多个返回值实际上还是单一值，是一个tuple类型。会按照位置赋给对应变量。 12345678910111213141516import mathdef quadratic(a, b, c): # 简洁表达多个变量的类型是否正确 if not isinstance((a + b + c),(int,float)): raise TypeError('Bad operand type') x1 = (-b + math.sqrt(b**2 - 4 * a * c)) / (2 * a) x2 = (-b - math.sqrt(b**2 - 4 * a * c)) / (2 * a) return x1, x2result = quadratic(1, -10, 9)result1, result2 = quadratic(1, -10, 9)print(result,type(result))print(result1, result2)","link":"/2019/08/13/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89-%E5%A4%9A%E5%80%BC%E8%BF%94%E5%9B%9E/"},{"title":"【学习笔记】Python学习笔记（二）-赋值方式","text":"斐波那契数列由0和1开始，之后的斐波那契系数就是由之前的两数相加而得出。首几个斐波那契系数是：0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233…… 先给出Fibonacci数列的求解方法： 12345678# 生成器方法求Fibonacci数列def fib(max): n, a, b = 0, 0, 1 while n &lt; max: yield b a, b = b, a + b n = n + 1 return 'done' 然后，比较两种赋值方式的区别： 分开两行赋值123456789101112131415161718192021222324252627282930313233a,b = 0,1print(a,b)print('----------------')a = bb = a+bprint(a,b)print('----------------')a = bb = a+bprint(a,b)print('----------------')a = bb = a+bprint(a,b)print('----------------')a = bb = a+bprint(a,b)print('----------------')# 运行结果:# 0 1# ----------------# 1 2# ----------------# 2 4# ----------------# 4 8# ----------------# 8 16# ---------------- 可见,b先赋值给a(即a先指向b所指向的内存),a获取了b的值（新值）,然后再进行a+b的运算,并赋值给了b。 写在一行赋值12345678910111213141516171819202122232425262728293031323334a,b = 0,1print(a,b)print('----------------')a,b = b, a+bprint(a,b)print('----------------')a,b = b, a+bprint(a,b)print('----------------')a,b = b, a+bprint(a,b)print('----------------')a,b = b, a+bprint(a,b)print('----------------')a,b = b, a+bprint(a,b)print('----------------')# 运行结果：# 0 1# ----------------# 1 1# ----------------# 1 2# ----------------# 2 3# ----------------# 3 5# ----------------# 5 8# ---------------- 可见,进行a+b运算时，并没有先将b赋值给a，a所采用的值是 旧的 值，得出的结果与Fibonacci数列一致。","link":"/2019/08/15/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89-%E8%B5%8B%E5%80%BC%E6%96%B9%E5%BC%8F/"},{"title":"【学习笔记】SSH身份验证和数据传输加密过程理解","text":"SSH目标​ 一、防止中间人攻击； ​ 二、身份鉴权（密码/免密）； ​ 三、加密传输； ssh-client和ssh-server涉及的文件/文件夹​ 1）ssh-server的**/etc/ssh**，该文件夹下有多个算法生成的密钥对（公钥和私钥） ​ 2）ssh-server的/home/user下的authorized_keys ​ 3）ssh-client的/home/user下的id_rsa和id_rsa.pub ​ 4）ssh-client的/home/user下的know_hosts 各个目标的解决方案对于目标一： ​ 在ssh-client首次连接ssh-server时，ssh-server会发一段fingerprint（该段fingerprint是由ssh-server根据自己public host key计算得来）。此时，需要ssh-client自行验证，ssh-server的这台主机是否为想要连接的主机，以此防止“中间人”攻击。（通常，ssh-server的public host key需要到证书中心（CA）作公证） ​ 当ssh-client输入yes，确认目前打算的连接到的ssh-server正确的话，ssh-server的/etc/ssh下的某一个算法的public host key，会被ssh-client的/home/user下的know_hosts所记录。 对于目标二： ​ 在ssh-client首次连接ssh-server，并输入yes确认ssh-server后（或者非首次连接），ssh-server需要对ssh-client的身份作验证。其中主要有两种身份验证方式：密码/免密登录。 ​ ssh-client以密码方式登录时，在会话建立过程中，会使用ssh-server发送过来的public host key，对输入的密码进行加密。待ssh-server收到，ssh-client使用public host key加密过后的密码后，ssh-server再使用private host key进行解密，得出明文密码。最后校验ssh-client的身份。 ​ ssh-client以免密登录方式登录前，需要先使用ssh-keygen生成一对密钥，这对密钥会存放在/home/当前用户名/.ssh目录下，默认参数会生成id_ras.pub和id_rsa。然后，使用ssh-copy-id -i id_rsa.pub 远端用户名@远端ip将当前用户的公钥id_rsa.pub上传至远端ssh-server。（此操作需要输入一次远端用户对应的密码） 对于目标三： ​ 事实上，SSH会话从建立到互相传输数据，主要分为两个部分。第一部分是ssh-client和ssh-server互相验证身份，第二部分是 使用DH算法算出当前会话的、临时的共享密钥，并使用共享密钥来加密互相传输的数据。其中，第一部分中的ssh-server对ssh-client进行身份验证，使用的是非对称加密的方式，而互相传输数据，使用的是对称加密。 成功建立安全信道进行传输的必要条件ssh-server： ​ 1）安装openssh-server（意味着会有ssh-keygen） ​ 2）生成host key（安装后会自动生成） ​ 3）启动sshd服务 ssh-client： ​ 1）安装openssh-client（意味着会有ssh-keygen）","link":"/2021/02/13/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91SSH%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E5%92%8C%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%8A%A0%E5%AF%86%E8%BF%87%E7%A8%8B%E7%90%86%E8%A7%A3/"},{"title":"【学习笔记】不同存储形式字符串的初始化和转换","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以char、char*、const char*、char[]、string形式存储的字符串的初始化、转换和处理。 char、char*、const char*、char[]、string的初始化char的初始化： 1char ch = 'c'; char *的初始化： 1char* str = &quot;A string here.&quot;; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用以上语句初始化char*变量，将会得到警告：warning: deprecated conversion from string constant to ‘char*’ [-Wwrite-strings]。事实上，这里char* str可看作是const char* str。 警告原因：以上语句的指针变量str位于栈区，而A string here.位于常量区，而常量区的内容是不可被修改的。如果指针变量str不以const修饰的话，即认为指针变量str所指向的内存区是可以被修改的，故产生警告，在尝试修改指针变量str指向的内存时，编译会产生错误，编译不通过。 const char*的初始化： 1const char* str = &quot;A string here.&quot;; 根据之前char *初始化的经验，应该以这种方式去初始化字符串，这种方式不会产生警告，当然，指针变量str指向的内存也是不被允许的。 char[] 的初始化： 1char str[] = &quot;A string here.&quot;; char[]（数组）可以看作是特殊的const指针。 https://blog.csdn.net/qq_34804120/article/details/80349180 string的初始化： 1string str = &quot;A string here.&quot;; string是C++的写法，string是一个类，而C语言并没有类的概念。 const char*、char[]、string之间的转换char类型仅可以保持一个字符，而不是一个字符串，所以无法与char*、const char*、char[]、string进行转换。 char*类型在初始化时，可看作是const char*，不额外多作讨论。 const char*转char[]： 12345678910111213#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main(){ const char* src = &quot;source string&quot;; char dst[] = &quot;default string&quot;; printf(&quot;dst:%s\\n&quot;, dst); // printf &quot;dst:default string&quot; strncpy(dst, src, 3); printf(&quot;dst:%s\\n&quot;, dst); // printf &quot;dst:souault string&quot; return 0;} const char*转string： 1234567891011121314#include&lt;stdio.h&gt;#include&lt;string&gt;#include&lt;iostream&gt;int main(){ const char* src = &quot;source string&quot;; std::string dst = &quot;default string&quot;; printf(&quot;dst:%s\\n&quot;, dst.c_str()); // printf &quot;default string&quot; dst = src; printf(&quot;dst:%s\\n&quot;, dst.c_str()); // printf &quot;source string&quot; return 0;} char[]转const char*： 1234567891011121314#include&lt;stdio.h&gt;#include&lt;string&gt;#include&lt;iostream&gt;int main(){ char src[] = &quot;source string&quot;; std::string dst = &quot;default string&quot;; printf(&quot;dst:%s\\n&quot;, dst.c_str()); // printf &quot;default string&quot; dst = src; printf(&quot;dst:%s\\n&quot;, dst.c_str()); // printf &quot;source string&quot; return 0;} char[]转string： 1234567891011121314#include&lt;stdio.h&gt;#include&lt;string&gt;#include&lt;iostream&gt;int main(){ char src[] = &quot;source string&quot;; std::string dst = &quot;default string&quot;; printf(&quot;dst:%s\\n&quot;, dst.c_str()); // printf &quot;default string&quot; dst = src; printf(&quot;dst:%s\\n&quot;, dst.c_str()); // printf &quot;source string&quot; return 0;} string转const char*： 1234567891011121314#include&lt;stdio.h&gt;#include&lt;string&gt;#include&lt;iostream&gt;int main(){ std::string src = &quot;source string&quot;; const char* dst = &quot;default string&quot;; printf(&quot;dst:%s\\n&quot;, dst); dst = src.c_str(); printf(&quot;dst:%s\\n&quot;, dst); return 0;} string转char[]： 1234567891011121314#include&lt;stdio.h&gt;#include&lt;string&gt;#include&lt;iostream&gt;int main(){ std::string src = &quot;source string&quot;; char[] dst = &quot;default string&quot;; printf(&quot;dst:%s\\n&quot;, dst); dst = src.c_str(); printf(&quot;dst:%s\\n&quot;, dst); return 0;} 字符串处理，memcpy()和strcpy()Referencehttps://www.huaweicloud.com/articles/a9419031c0b854d66abd2a8f71b00a5d.html https://blog.csdn.net/qq_34804120/article/details/80349180","link":"/2021/03/28/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E4%B8%8D%E5%90%8C%E5%AD%98%E5%82%A8%E5%BD%A2%E5%BC%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E8%BD%AC%E6%8D%A2/"},{"title":"【学习笔记】共用体 - union","text":"​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;共用体（英文：Union），又名联合体。共用体所有成员共享同一片存储区/内存，因此联合变量同一时刻里，只能保存其中某一个成员的值。 应用场景&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;想象这样一个场景。假设需要根据用户的输入，将其保存为数值（如果它是数值）或字符串（如果它是字符串）。在这种情况下，一种解决方案是为数值和字符串分别开辟空间，但是由于输入是数字值或字符串，因此仅使用了一个，这很浪费空间。因此，代替地，可以通过仅准备一个存储区域，并且在根据情况，将其解释为数值或字符串，以此来减小空间的浪费。这个“存储区域”就是共用体。 举例​ 共用体的一般形式如下： 12345union 共用体名{ 数据类型 成员名； 数据类型 成员名； ...}变量名； &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了从共用体中提取并解释有意义的值，除了数据本身之外，一般还需要保存“当前共用体包含了什么类型的数据”，作为附加信息。 定义一个包含共用体的类型： 123456789typedef struct { int dataType; union U_val{ char c; short sh; int i; unsigned char buff[256]; };}S_unionVal; 此处，dataType就是附加信息，有了这个附加信息，我们在解释共用体U_val的时候，就会更加的方便。 以上共用体的内存分配状态，如图： 共用体有几个特性： ​ ① 共用体变量所占的内存，由共用体成员中占用空间最大的成员决定。 ​ ② 共用体中的所有成员共享同一片内存空间，对某一共用体成员赋值，可能会覆写其他成员的值。 ​ ③ 共用体成员从低地址向高地址赋值。 下面用三个例子来说明以上特性， 1234567891011121314151617#include&lt;stdio.h&gt;typedef struct { int dataType; // 4 bytes union U_val{ char c; // 1 bytes short sh; // 2 bytes int i; // 4 bytes unsigned char buff[256]; // 256 bytes }val;}S_unionVal;int main(){ S_unionVal value; printf(&quot;Variable value's size is %d.\\n&quot;, sizeof(value)); //Variable value's size is 260.} 260 = 4（dataType） + 256（buff[256]） 由此，可以证明特性① 共用体变量所占的内存，由共用体成员中占用空间最大的成员决定。 12345678910111213141516171819202122#include&lt;stdio.h&gt;typedef struct { int dataType; union U_val{ char c; short sh; int i; unsigned char buff[256]; }val;}S_unionVal;int main(){ S_unionVal value; value.val.c = 'a'; printf(&quot;value.val.c is %c.\\n&quot;, value.val.c); // value.val.c is a. value.val.i = 100; printf(&quot;value.val.i is %i.\\n&quot;, value.val.i); // value.val.i is 100. printf(&quot;value.val.c is %c.\\n&quot;, value.val.c); // value.val.c is d.} 首次赋值后，当通过%c来解释**共用体成员c**的时候，得到输出为字符a。 而第二次赋值后，再次通过%c来解释**共用体成员c**的时候，得到输出从字符a变更为字符d，而字符d的ASCII码正是100。 由此可见，当为共用体成员i**赋值时，共用体成员c**的值被覆写了。 得出特性② 共用体中的所有成员共享同一片内存空间，对某一共用体成员赋值，可能会覆写其他成员的值 的结论。 12345678910111213141516171819202122232425262728#include&lt;stdio.h&gt;typedef struct { int dataType; union U_val{ char c; short sh; int i; unsigned char buff[256]; }val;}S_unionVal;int main(){ S_unionVal value; printf(&quot;value.val.c's address is %p.\\n&quot;, &amp;value.val.c); printf(&quot;value.val.sh's address is %p.\\n&quot;, &amp;value.val.sh); printf(&quot;value.val.i's address is %p.\\n&quot;, &amp;value.val.i); printf(&quot;value.val.buff's address is %p.\\n&quot;, &amp;value.val.buff); char* str = &quot;This is a string.&quot;; memcpy(value.val.buff, str, strlen(str) + 1); printf(&quot;Print first 20 bytes of buff[256]: |&quot;); for(int i = 0; i &lt; 20; i++){ printf(&quot;%c|&quot;, value.val.buff[i]); } printf(&quot;\\n&quot;);} 输出： 12345value.val.c's address is 0x7ffde8ce9774.value.val.sh's address is 0x7ffde8ce9774.value.val.i's address is 0x7ffde8ce9774.value.val.buff's address is 0x7ffde8ce9774.Print first 20 bytes of buff[256]: |T|h|i|s| |i|s| |a| |s|t|r|i|n|g|.|||| 所有共用体成员的地址均一致，正因为这个原因，对某一共用体成员赋值后，可能会覆写其他成员的值。 解释一下，为什么memcpy()第三个参数是strlen(str) + 1，这是因为指针变量str所指向的字符串在末位包含一个\\0结束符，而strlen()返回的长度，并不包含\\0结束符。 256个bytes中，观察前20个bytes，在这20个bytes中，前18个bytes被赋值（“This is a string.” 17个bytes和\\0结束符1个byte），而其后的2个bytes并未被赋值，可得，特性③ 共用体成员从低地址向高地址赋值。 Reference： https://ja.wikipedia.org/wiki/%E5%85%B1%E7%94%A8%E4%BD%93 https://www.lmlphp.com/user/56/article/item/7603/","link":"/2021/03/28/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E5%85%B1%E7%94%A8%E4%BD%93-union/"},{"title":"【学习笔记】字节序","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;字节序，即字节顺序，又称端序或尾序（英语：byte-order/ Endianness），在计算机科学领域中，指电脑内存中或在数字通信链路中，组成多字节的字的字节的排列顺序。在几乎所有的机器上，多字节对象都被存储为连续的字节序列。例如在C语言中，一个类型为int的变量x地址为0x100，那么其对应地址表达式&amp;x的值为0x100。且x的四个字节将被存储在电脑内存的0x100, 0x101, 0x102, 0x103位置。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如假设上述变量x类型为int，位于地址0x100处，它的值为0x01234567，地址范围为0x100~0x103字节，其内部排列顺序依赖于机器的类型。大端法从首位开始将是：0x100: 0x01, 0x101: 0x23,..。而小端法将是：0x100: 0x67, 0x101: 0x45,..。 大端序、小端序及混合序&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在讲字节序之前，先明确高/低位地址和高/低位字节的含义。先说高/低地址，内存中的每一个值都会对应到一个内存地址，而每个内存地址都会有一个编号，编号的大小则对应地址的高低。然后轮到高/低位字节，在十进制中，靠左边的是高位，靠右边的是低位，在其他进制也是如此。就拿 0x12345678 来说，从高位到低位的字节依次是 0x12、0x34、0x56 和 0x78。（十六进制，每两个十六进制位为一个字节）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;字节的排列顺序通常主要有三种，分别是小端序（英：little-endian）、大端序（英：big-endian）和混合序（英：middle-endian）。将一个多字节对象的低位字节放在内存的低地址端，高位字节排放在内存的高地址端，则称小端序；反之则称大端序。还有一种，在一个多字节对象中同时存在大端序和小端序，称为混合序。 大端字节序&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将一个多字节对象的高位字节放在内存的低地址端，低位字节排放在内存的高地址端，这是易于人类阅读的存储方法。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如图所示，高位字节0A放在最低位地址a，而低位字节0D放在最高位地址a+3。 小端字节序&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 将一个多字节对象的低位字节放在内存的低地址端，高位字节排放在内存的高地址端。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如图所示，高位字节0A放在最高位地址a+3，而低位字节0D放在最低位地址a。 混合字节序&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在一个多字节对象中，同时存在大端字节序和小端字节序。例如，在一个32bit对象中，前16bit与后16bit的字节序为小端序，而这16bit的内部为大端序。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如图所示，高位字节0A和0B分别放在低位地址a+1和a，而低位字节0C和0D分别放在高位地址a+3和a+2。把0A和0B看作是一个整体，而把0C和0D看作是另外一个整体的话，那么，这两个整体的排列顺序就是大端序。而在0A和0B这个整体之内，0A和0B的排列顺序则是小端序。 字节序的存在意义&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为什么存在小端字节序？计算机逻辑电路先处理低位字节，效率比较高，因为计算都是从低位开始的。所以，许多内部处理都是小端字节序。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为什么存在大端字节序？人类还是习惯读写大端字节序。所以，除了计算机的内部处理，其他的场合几乎都是大端字节序，比如网络传输和文件储存。 网络字节序和主机字节序&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;网络字节序（Network Byte Order），始终为大端顺序。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;主机字节序（Host Byte Order），不同的机器的主机字节序不相同，与CPU设计有关。 数据解析&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;解析/格式化是计算机科学的主要学科之一。 这是将数据的外部格式（文件格式，网络协议，硬件寄存器）转换为内部格式（软件所操作的数据结构）的过程。 ​ One of the major disciplines in computer science is parsing/formatting. This is the process of converting the external format of data (file formats, network protocols, hardware registers) into the internal format (the data structures that software operates on). &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;外部格式必须有明确定义。对于文件格式，有GIF文件、JPEG文件和MPEG文件等；对于网络协议，格式会以RFC的形式编写。这些格式，会将每一个字节的含义都规定好。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;举例来说，假设处理器读入了一个外部的、大端字节序的16位整数x时，处理器按照以下方式转换成内部格式的值： 1x = buf[offset] * 256 + buf[offset + 1]; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf是整个16位数据块在内存中的起始地址，offset是当前正在读取的位置。第一个字节乘以256，再加上第二个字节，就是大端字节序的值，这个式子可以用逻辑运算符改写。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;进一步假设x的十进制值为256，那么其对应的二进制值为00000001 00000000，这个16位数据块的第一个字节的十进制值为1，第二个字节的十进制值为0，根据以上代码，可还原出16位数据块整体的十进制值为256。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;代码用逻辑运算符可以改写成： 1x = buf[offset]&lt;&lt;8 | buf[offset+1]; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面代码中，第一个字节左移8位（即后面添8个0），然后再与第二个字节进行或运算。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果外部格式是小端字节序，用下面的公式转成内部格式的值： 1x = buf[offset+1] * 256 + buf[offset]; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;32位整数的求值公式也是相似的： 12345/* 大端字节序 */i = (data[3]&lt;&lt;0) | (data[2]&lt;&lt;8) | (data[1]&lt;&lt;16) | (data[0]&lt;&lt;24);/* 小端字节序 */i = (data[0]&lt;&lt;0) | (data[1]&lt;&lt;8) | (data[2]&lt;&lt;16) | (data[3]&lt;&lt;24); Reference: https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E5%BA%8F#%E5%AD%97%E8%8A%82%E9%A1%BA%E5%BA%8F https://www.ruanyifeng.com/blog/2016/11/byte-order.html https://blog.erratasec.com/2016/11/how-to-teach-endian.html#.YFg1Dq8zZPY https://www.cnblogs.com/onepixel/p/7468343.html","link":"/2021/03/22/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E5%AD%97%E8%8A%82%E5%BA%8F/"},{"title":"【学习笔记】进程间&#x2F;线程间通信（零）","text":"​ 进程间通信（IPC，Inter-Process Communication），指至少两个进程或线程间传送数据或信号的一些技术或方法。 ​ 进程是计算机系统分配资源的最小单位（严格说来是线程）。每个进程都有自己的一部分独立的系统资源，彼此是隔离的。为了能使不同的进程互相访问资源并进行协调工作，才有了进程间通信。通常，使用进程间通信的两个应用可以被分为客户端和服务器（见主从式架构），客户端进程请求数据，服务端响应客户端的数据请求。有一些应用本身既是服务器又是客户端，这在分布式计算中，时常可以见到。这些进程可以运行在同一计算机上或网络连接的不同计算机上。 Method Description Provided by (operating systems or other environments) 文件（File） A record stored on disk, or a record synthesized on demand by a file server, which can be accessed by multiple processes. Most operating systems 信号量（Signal） A system message sent from one process to another, not usually used to transfer data but instead used to remotely command the partnered process. Most operating systems 套接字（Socket） Data sent over a network interface, either to a different process on the same computer or to another computer on the network. Stream-oriented (TCP; data written through a socket requires formatting to preserve message boundaries) or more rarely message-oriented (UDP, SCTP). Most operating systems Unix domain socket Similar to an internet socket, but all communication occurs within the kernel. Domain sockets use the file system as their address space. Processes reference a domain socket as an inode, and multiple processes can communicate with one socket All POSIX operating systems and Windows 10 消息队列（Message queue） A data stream similar to a socket, but which usually preserves message boundaries. Typically implemented by the operating system, they allow multiple processes to read and write to the message queue without being directly connected to each other. Most operating systems 匿名管道（Anonymous pipe） A unidirectional data channel using standard input and output. Data written to the write-end of the pipe is buffered by the operating system until it is read from the read-end of the pipe. Two-way communication between processes can be achieved by using two pipes in opposite “directions”. All POSIX systems, Windows 命名管道（Named pipe） A pipe that is treated like a file. Instead of using standard input and output as with an anonymous pipe, processes write to and read from a named pipe, as if it were a regular file. All POSIX systems, Windows, AmigaOS 2.0+ 共享内存（Shared memory） Multiple processes are given access to the same block of memory, which creates a shared buffer for the processes to communicate with each other. All POSIX systems, Windows 消息传递（Message passing） Allows multiple programs to communicate using message queues and/or non-OS managed channels. Commonly used in concurrency models. Used in RPC, RMI, and MPI paradigms, Java RMI, CORBA, DDS, MSMQ, MailSlots, QNX, others 内存映射文件（Memory-mapped file） A file mapped to RAM and can be modified by changing memory addresses directly instead of outputting to a stream. This shares the same benefits as a standard file. All POSIX systems, Windows Reference : https://zh.wikipedia.org/wiki/%E8%A1%8C%E7%A8%8B%E9%96%93%E9%80%9A%E8%A8%8A https://en.wikipedia.org/wiki/Inter-process_communication","link":"/2021/02/18/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E8%BF%9B%E7%A8%8B%E9%97%B4%E6%88%96%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%88%E9%9B%B6%EF%BC%89/"},{"title":"【常用工具】虚拟机使用宿主机代理","text":"​ 以下以VMWare为例，记录了如何使得虚拟机使用宿主机代理的方法。 虚拟机系统代理设置Step 0：宿主机代理软件，打开【允许局域网连接】。 Step 1：打开System Setting Step 2：打开Network Step 3：选择Network proxy Step 4：Method选择Manual，并填入【宿主机的IP地址】和【宿主机代理软件的本地监听端口】。 终端代理设置Tips : 仅对当前终端有效 1234export http_proxy=&quot;http://192.168.xxx.xxx:xxxx&quot;export https_proxy=&quot;https://192.168.xxx.xxx:xxxx&quot;","link":"/2021/02/17/%E3%80%90%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E3%80%91%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%BD%BF%E7%94%A8%E5%AE%BF%E4%B8%BB%E6%9C%BA%E4%BB%A3%E7%90%86/"},{"title":"【常用工具】VMWare共享文件夹挂载","text":"​ 以下记录了VMWare与宿主机之间，共享文件夹的配置方法。 共享文件夹挂载功能开启详细步骤Step 1：打开工具栏中的Player Step 2：选择管理 Step 3：选择虚拟机设置 Step 4：选择选项 选项卡 Step 5：选择共享文件夹 Step 6：选择总是启用 Step 7：点击添加 Step 8：根据提示填入主机路径和名称（名称会根据主机路径自动填入） Step 9：启用此共享（默认勾选） Step 10：点击完成 Step 11：挂载共享文件夹 开机自动挂载方法用编辑器打开/etc文件夹下的fstab文件： 1# vi /etc/fstab 末尾追加一行： 1.host:/ /mnt/hgfs fuse.vmhgfs-fuse allow_other,defaults 0 0 手动挂载方法1vmhgfs-fuse .host:/ /mnt/hgfs 访问共享文件夹cd至/mnt/hgfs目录下，方可访问共享文件夹。","link":"/2021/02/17/%E3%80%90%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E3%80%91VMWare%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%A4%B9%E6%8C%82%E8%BD%BD/"},{"title":"【金融理财】投资策略","text":"​ 通过上一篇文章，我们对基金是什么，有了一个大致的理解。并认识了一些常见的基金分类。本文则是总结了部分基金投资相关的网络资源，为最终的基金理财实战，提供基本的基金投资方法论。本文主要解决如何购买基金的问题。 信息来源「晨星网」 http://cn.morningstar.com/main/default.aspx 这是一家全球性的基金资讯网站，里面会发布很多最新的基金投资资讯消息，还有 一个很好的功能，就是里面有一个基金筛选器的页面，可以根据你输入的信息，筛选 出费率最低，安全性和稳定性最靠前的对应基金，很好用，新人选基金的时候用的 上。 「雪球网」 https://xueqiu.com/ 这里面都是一些资深的股票投资者，还有基金投资者，里面写投资的大 V也很 多，讲的内容都是原创，网上看不到的，干货内容也有挺多，想多了解别人投资经 验的没事可以多看看，但是也要注意甄别内容，毕竟投资是敏感领域，不要轻信别人直接给你推荐的股票和基金什么的。 「天天基金网」 https://1234567.com.cn/ 刚才讲实操的时候，用的就是天天基金网的 APP，里面可以进行基金交易，是比 较大的平台，安全性可以放心，里面还有，定投计算器，收益计算器这些使用工具， 也可以查询所有注册基金的往年历史走势和数据，功能很多，都可以用。 「上证官网」 http://www.sse.com.cn/ 上海证券交易所的官方网站，可以看到上证指数成立以来的走势数据，也可以查 询上海证券交易所里面所有的基金数据 「且慢」APP 「蛋卷」APP 「乐咕」https://www.legulegu.com/stockdata/a-ttm-lyr 「同花顺」了解行情动态 「东方财富」了解行情动态 「萝卜投研」财经信息平台 「财联社」财经信息平台 「巨潮网」上市公司信息披露网站 「证监会」 「保监会」 「银监会」 一般性常识1、中证500和沪深300 中证500和沪深300都是指数型基金。 中证500：A股市场中500家中小规模的公司（基数低，易翻倍） 描述：进攻型基金 沪深300：我们国家股票市场上的300支规模比较大，业绩也比较稳定的公司 描述：大概率长期是可以赚到钱。沪深300在市场环境不怎么好的适合，作为护盘的角色出现；当市场环境特别好的时候，它的表现就不一定能够超越大盘指数的涨幅。 2、不要在下午3点之后买卖基金。因为A股在下午3点收盘，3点以后，实际的买卖会在第二天进行。 3、PE。Price-to-Earning Ratio，P/E 或 PER，又称为市盈率。相对低点买入，相对高点卖出 4、基金分红，选择现金还是分红再投资？ 结合市盈率，分情况讨论。 5、影响股价的三个因素： ​ ① 大众的心理预期 ​ ② 投资者的心理博弈 ​ ③ 基本面的考量 注：基本面指的是一家公司多个维度的数据以及情况，如公司的财务状况、盈利情况、行业发展前景、市场占有率等 股票的价格是围绕着股票的内在价值而上下波动的 筛选和买入① 基金用短期内不使用的闲钱买。 ② 基金长期持有。 ​ 只要不是牛市顶点入场，拉长周期来看，95%的基金都是可以盈利的。 ③ 选择合适的基金销售平台。 ​ 常见的销售机构有商业银行、基金公司直销和第三方平台。 ​ 商业银行：手续费贵！ ​ 基金公司直销：这种方式只能购买这一家基金公司旗下的基金产品，而不能够选择其他公司的产品。 ​ 第三方平台：如支付宝和天天基金等，相对于商业银行，手续费为1/10左右。 ④ 选择优秀的基金公司。 ​ 在同等条件下，选择基金公司实力更强的，即规模更大的基金公司。基金公司实力强的，才更有钱去招聘优秀的基金经理、投研团队，形成良性循环。 ⑤ 选择优秀的基金经理。 ​ 选择基金，从某种程度上说，就是选择基金经理。基金经理投资水平的高低，决定了 投资者收益的高低。（从业年限越久越好，跳槽次数越少越好） 根据收益率（&gt;15%）、基金规模（100亿以上）、控制回撤能力、获奖次数、优良业绩持续时间（5年以上），得出Top10基金经理： 张坤，易方达萧楠，易方达王崇，交银施罗德傅鹏博，睿远杨浩，交银施罗德谢志宇，兴证全球葛兰，中欧朱少醒，富国周应波，中欧傅友兴，广发 ⑥ 合适的管理规模 ​ 一般选择50-100亿规模的基金。 ⑦ 尽量选择多元化基金 ​ 投资标的尽量分散在多个主题，中国投资市场还不完善，根据风口，基金会轮动上涨。分散投资，有利于对冲风险。 ⑧ 基金买旧不买新 ​ i 老基金的收益基金经理的主要收入，相对更加稳妥。 ​ ii 新基金在建仓期，可能会错过牛市。 ⑨ 定投，摊平成本，对抗风险。 ​ 基金定投，是定期投资基金的简称，在固定的时间，投资到固定的基金或者基金组合种。定投一般是股票型基金和指数型基金。 ​ 定投方式： ​ 1） 懒人定投： ​ 在固定时间买入固定金额的基金或者基金组合。 ​ 适合人群，没有基金持仓，没时间每天看净值。 ​ 2）智能定投法 ​ 系统根据特定算法。 ​ 3） 进阶定投法 ​ PE TTM超过60，停止定投， ​ 在明显脱离成本区间后，从上一个高点，单次/累计下跌4%，买入固定金额。 最大回撤，一般在15%-30%，即使是极端行情，很少会出现40%。 每天3点前一点时间，关注净值估算。 基金组合四不不买同一个主题的基金 不买同一个基金经理的基金 不买同一个基金公司的基金 不买重仓股重叠过多的基金 市场分散A股、港股、美股 行业行业能长期诞生大牛股，利润增长持续且稳定 非周期性行业，不存在明显的淡旺季 行业存续时间长，行业市值占比高 得出：消费、医药、科技、（金融） 优选基金优选2-3只基金，数量不宜多 风格明显差异的基金经理价值股投资 成长股投资 风格稳健 风格基金 如何得知风格：看基金经理持仓，翻阅基金经理年报，看基金经理公开演讲。 何时卖出① 所购买的基金更换了基金经理。 ② 基金经理投资风格突变。 ③ 市场出现极端行情。 动态市盈率等权平均法，PE 小于40，称为低估，大于60，高估，大于80，市场疯狂。 45分批买入，60以上分批卖出。","link":"/2021/02/18/%E3%80%90%E9%87%91%E8%9E%8D%E7%90%86%E8%B4%A2%E3%80%91%E6%8A%95%E8%B5%84%E7%AD%96%E7%95%A5/"},{"title":"【金融理财】基金常识和相关概念","text":"​ 写这篇文章是为基金理财做准备，并以这种理财方式增加被动收入。而本文主要解决，基金是什么以及为什么要购买基金的问题。 基金是什么​ 买基金到底买了什么东西？投资者购买基金需要花两笔钱，一笔是实际用于投资理财的钱，另一笔则是管理费。完成了购买基金操作后，实际上是用管理费委托了基金管理公司（具体到某一位基金经理），将实际用于投资理财的钱投资到股票或债券等。投资者的收益主要来自股票或债券升值所带来的收益。相对于自行购买理财，购买基金可以让相对专业的基金经理替投资者选择和决策，可以一定程度上规避风险，提高总收益。 基金的分类风险高到低，基金可以分为以下几类： 股票型/QDII型/混合型 指数型 FOF型 债券基金（纯债基金、混合债基金、可转债基金） 货币型 风险和受益是对等的。 股票型/QDII型/混合型​ 待补充。 指数型分为宽基指数基金，窄基指数基金（又叫行业指数基金）。 窄基指数基金：一般是针对某一个行业的指数型基金，需要对该行业有一定的了解和认知。 宽基指数基金：不论什么行业，只有公司规模大小的区别。 目前主流的四种指数，大公司指数【沪深300，上证50】，中小公司指数【中证500，创业板指】。 沪深300：我们国家内地市场上，有两个主要的证券交易所，一个在上海（上海证券交易所），一个在深圳（深圳证券交易所）。沪深300就是这两个市场加在一起，挑300家规模最大、流动性最好的公司，组成这个指数。 风格：金融和地产的占比比较大，其次混合了消费、工业等，和国家经济息息相关。特别稳。 上证50：挑上海50家规模最大、流动性最好的公司，组成这个指数。 中证500：以消费和工业为主导的指数类型。 创业板指：风险最高的宽基指数。行业分布主要是医药、工业、互联网信息技术。大部分是新兴产业，很大程度上反映了新兴产业公司发展的状况。 FOF型会规避掉不好的基金。但多重手续费，最后受益除去手续费没有多少。 债券基金债券基金分为纯债、混合债和可转债三种。 纯债：基金持仓基本是用来买国债、企业债。年化一般在3% ~ 4.5%。 混合债：一大半用来买债券，债券包括国债、企业债和可转债，一小部分用来买股票或其他。买混合债，是希望稳重求进，收益率稍微高一点点，但风险又不要太大。40%以上用于买股票，风险略高，不大符合买混合债基金的原始目标。债券持仓比例，债券的持仓比例在70%-90%比较合适， 可转债：名义上是债券，实际上有公司和股票的属性。当公司想做一件事情，但又暂时不想拿自己的钱出来的时候，就会向市面上发售一些债券。这些债券当中，一小部分可以转换成公司的股票，这部分就叫做可转债金。（新手放弃） 货币型​ 货币型基金主要投资于债券、央行票据、回购等安全性极高的短期金融品种，又被称为“准储蓄产品”，其主要特征是“本金无忧、活期便利、定期收益、每日记收益、按月分红利”。 货币型基金只投资于货币市场，如短期国债、回购、央行票据、银行存款等等，风险基本没有。 估值指标市盈率​ 股票的市盈率 (Price-to-Earning Ratio，P/E 或 PER)，又称为市盈率，指每股市价除以每股盈余 (Earnings Per Share，EPS)，通常作为股票是便宜抑或昂贵的指标 (通货膨胀会使每股收益虚增，从而扭曲市盈率的比较价值)。市盈率把企业的股价与其制造财富的能力联系起来。 ​ 每股盈余的计算方法，一般是以该企业在过去一年的净利润，除总发行已售出股份净值。市盈率越低，代表投资者能够以相对较低价格购入股票。假设某股票的市价为 24 元，而过去一年的每股盈余为 3 元，则市盈率为 24/3=8。该股票被视为有 8 倍的市盈率，即假设该企业以后每年净利润和去年相同的基础上，如果不考虑通货膨胀因素，回本期为 8 年，折合平均年回报率为 12.5%，投资者每付出 8 元可分享 1 元的企业盈利。但上市公司通常只会把部分盈利用来派发股息，其余用来作进一步发展，所以市盈率的倒数并不直接等同于股息率。 ​ 投资者计算市盈率，主要用来比较不同股票的价值。理论上，股票的市盈率愈低，表示该股票的投资风险越小，愈值得投资。比较不同行业、不同国家、不同时段的市盈率是不大可靠的，比较同类股票的市盈率较有实用价值。 计算方法市盈率＝每股市价／每股盈余 决定股价的因素​ 股价取决于市场需求，即变相取决于投资者对以下各项的期望： 企业的最近表现和未来发展前景 新推出的产品或服务 该行业的前景其余影响股价的因素还包括市场气氛、新兴行业热潮等。市盈率把股价和利润联系起来，反映了企业的近期表现。如果股价上升，但利润没有变化，甚至下降，则市盈率将会上升。 平均回报率美国股票的市盈率平均为 14 倍，表示回本期为 14 年。14 倍 PER 折合平均年回报率为 7% (1/14)。 市盈率所代表的意义如果某股票有较高市盈率，则有可能因以下原因： 市场预测未来的盈利增长速度快。 该企业一向录得可观盈利，但在前一个年度出现过一次性的特殊支出，降低了盈利。 出现泡沫，该股被以超过其内在价值的价格在交易。 该企业有特殊的优势，保证能在低风险情况下持久录得盈利。 市场上可选择的股票有限，在供求定律下，股价将上升。这令跨时间的市盈率比较变得意义不大。 如果某股票有较低市盈率，则有可能因以下原因： 市场预测该企业和去年相比较，盈利将减少，企业价值将下降。 该企业在去年出现过一次性的特殊收入，暂时提高了去年的盈利。 该股的价格被市场低估。 股票的供给超过了市场上资金的投资需求。※值得一提，如果某股票的市盈率为零，即代表股票去年是在于亏损状态。 计算利用不同的数据计出的市盈率，有不同的意义。现行市盈率利用过去四个季度的每股盈余计算，而预测市盈率可以用过去四个季度的盈利计算，也可以根据上两个季度的实际盈利以及未来两个季度的预测盈利的总和计算。 静态市盈率PE (LYR) ，Last Year Ratio，静态市盈率＝市价／最近一个财政年度的每股盈利 动态市盈率动态市盈率（PEG），其计算公式是以静态市盈率为基数，乘以动态系数。 该系数为1/(1+i)n，i为企业每股收益的增长性比率，n为企业的可持续发展的存续期。上市公司目前股价为20元，每股收益为0.38元，去年同期每股收益为0.28元，成长性为35%，即i=35％，该企业未来保持该增长速度的时间可持续5年，即n=5，则动态系数为1/(1+35%)5=22%。相应地，动态市盈率为11.6倍（静态市盈率：20元/0.38元=52倍；动态市盈率：52倍×22％=11.6倍）。 滚动市盈率 PE (TTM) ，Trailing Twelve Months，以当前总市值，除以前面四个季度的总净利润 盈利收益率盈利收益率简称E/P，是P/E的倒数，盈利收益率越高也就代表这支指数基金越值得投资。 当盈利收益率大于 **10%**的时候，这支基金就比较适合我们开始投资了。所以我 们在挑选低估值指数基金的时候，根据「盈利收益率」这个指标，大于10%都 可以定投，如果低于 10%则不太适合定投。 适用范围无论是市盈率还是盈利收益率，我们只能用在盈利较为稳定的品种上面，如白酒行业、家电行业。这样我们PE中的E才具有参考价值，对于周期性很强，或者盈利会暴涨暴跌的行业并不适用。 市净率股票的市净率（Price-to-Book Ratio, PBR, P/B），又名市账率、股價淨值比，指每股市价除以每股净资产，通常作为股票孰贱孰贵的指标之一。 计算方法股票的市净率＝每股市价／每股净资产 适用范围市净率特别在评估高风险企业，企业资产大量为实物资产的企业时受到重视。 净资产收益率净资产收益率，ROE，也就股东报酬率，是企业净利润与净资产的比值，其数值大小也代表了企业盈利能力的大小。 计算ROE = 净利润 /净资产 举个例子：A公司一年的利润为20万，占用资本300万，B公司一年的利润10万，占用资本100万； 看上去A公司赚的利润多，但是A资本回报率为6.66%，B公司为10%，显然B公司如果用同样钱，可以赚更多钱，更有投资价值。 净资产收益率是巴菲特最为看重的股票估值指标，他选中并长期持有的股票基本都是净资产收益率常年保持在**20%**以上的企业。 总之，指数的净资产收益率越高越好。 净资产收益率更偏向于基本面分析，不涉及股价波动。 股息率股息率是股息与股票价格之间的比率。在投资实践中，股息率是衡量企业是否具有投资价值的重要标尺之一。 例：现金股利为1元，股价20元，则股息率为5%；若来年配息仍为1元，股价已至25元，则股息率降为4%。 当然，股息率越高越好。 计算股息率=每股股利／每股股价","link":"/2021/02/18/%E3%80%90%E9%87%91%E8%9E%8D%E7%90%86%E8%B4%A2%E3%80%91%E5%9F%BA%E9%87%91%E5%B8%B8%E8%AF%86%E5%92%8C%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"title":"【金融理财】支付宝基金界面详解","text":"​ 支付宝基金购买操作界面。 基金名称含义​ 基金名称主要由公司名称+投资范围/基金特点+基金类型组成。 例如，易方达中小盘混合， 易方达，为易方达基金管理有限公司。 中小盘，会购买中小盘的股票、债券。 混合，投资于股票、债券和货币等。 后缀释义： A和C：A类基金和C类基金的区别主要体现在三种费用上， 前端申购费：A类基金在买入基金时候，需要一次性付款申购费（0.1% ~ 0.15%）；C类基金不需要。 销售服务费：A类基金在持有基金过程中，无需承担额外承担销售服务费；C类基金需要持续付费（0.5%/年） 赎回费：赎回费随着投资者持有时间越长，费率会逐渐降低，直至0%。A类基金需要持有较长时间（半年以上），C类基金需要持有较短时间（一个月以上） 综上，A类基金适合长期持有，C类基金适合短期持有。 增强：以沪深300为例，原本只能买沪深300指数编制中的公司，但如果基金名称带增强，那么它大部分会买沪深300指数以内的公司，其他部分会买沪深300指数以外的公司。同类产品中，比较激进。 ETF和ETF联接：Exchange-Traded Funds，缩写为ETF，即交易型开放式指数基金。ETF仅可以场内交易，无法在二级市场购买，如互联网。但基金公司为了让那些没有证券账户、无法在证券公司进行该ETF交易的投资者，也能对该ETF基金进行投资，以ETF联接的形式，复制了一个场外可以申赎的指数基金。 LOF： Listed Open-Ended Fund，缩写为LOF，即上市型开放式基金。相比ETF，区别主要是缺少了指数二字，指数型基金仅可以购买被编进指数的公司，而LOF不受此限制。 QDII： Qualified Domestic Institutional Investor，缩写为QDII，即合格境内机构投资者。它是在一国境内设立，经该国有关部门批准从事境外证券市场的股票、债券等有价证券业务的证券投资基金。它也是在货币没有实现完全可自由兑换、资本项目尚未开放的情况下，有限度地允许境内投资者投资境外证券市场的一项过渡性的制度安排。简单来说，就是投资者可以投资大陆外的基金。 费用产生① 买入费率 前端申购费 ② 运作费率： 管理费 托管费 销售服务费 ③ 卖出费率： 赎回费 待续…","link":"/2021/02/28/%E3%80%90%E9%87%91%E8%9E%8D%E7%90%86%E8%B4%A2%E3%80%91%E6%94%AF%E4%BB%98%E5%AE%9D%E5%9F%BA%E9%87%91%E7%95%8C%E9%9D%A2%E8%AF%A6%E8%A7%A3/"},{"title":"【生活日常】应季蔬果","text":"​ 分别按品种和月份梳理应季水果。（搬运自省心果园） 按品种： 按月份：","link":"/2021/03/21/%E3%80%90%E7%94%9F%E6%B4%BB%E6%97%A5%E5%B8%B8%E3%80%91%E5%BA%94%E5%AD%A3%E8%94%AC%E6%9E%9C/"}],"tags":[{"name":"C&#x2F;C++","slug":"C-C","link":"/tags/C-C/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"go","slug":"go","link":"/tags/go/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"ssh","slug":"ssh","link":"/tags/ssh/"},{"name":"byte-order","slug":"byte-order","link":"/tags/byte-order/"},{"name":"IPC","slug":"IPC","link":"/tags/IPC/"},{"name":"virtual machine","slug":"virtual-machine","link":"/tags/virtual-machine/"},{"name":"fund","slug":"fund","link":"/tags/fund/"},{"name":"fruits","slug":"fruits","link":"/tags/fruits/"}],"categories":[{"name":"学习笔记","slug":"学习笔记","link":"/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"坑","slug":"坑","link":"/categories/%E5%9D%91/"},{"name":"常用工具","slug":"常用工具","link":"/categories/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/"},{"name":"金融理财","slug":"金融理财","link":"/categories/%E9%87%91%E8%9E%8D%E7%90%86%E8%B4%A2/"},{"name":"生活日常","slug":"生活日常","link":"/categories/%E7%94%9F%E6%B4%BB%E6%97%A5%E5%B8%B8/"}]}